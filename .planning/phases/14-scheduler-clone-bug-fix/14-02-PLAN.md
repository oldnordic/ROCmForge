---
phase: 14-scheduler-clone-bug-fix
plan: 02
type: execute
wave: 2
depends_on: [14-01]
files_modified:
  - src/scheduler/scheduler.rs
autonomous: true

must_haves:
  truths:
    - "Token preservation logic uses HashMap::entry API for clarity"
    - "All scheduler tests still pass after refactor"
    - "Code is more readable (explicit Vacant/Occupied handling)"
  artifacts:
    - path: "src/scheduler/scheduler.rs"
      provides: "Refactored update_iteration_batch with Entry API"
      min_lines: 650
      contains: "Entry::"
  key_links:
    - from: "std::collections::hash_map::Entry"
      to: "update_iteration_batch"
      via: "use import"
      pattern: "use std::collections::hash_map::Entry"
---

<objective>
Refactor update_iteration_batch to use HashMap::entry API for cleaner implementation.

The current workaround (lines 636-640) works but uses nested if-let. The Entry API provides a more idiomatic pattern that makes the intent clearer: only update if the batch has fresher data.

**This is OPTIONAL** - the current implementation works. The refactor improves code clarity and maintainability.

Purpose: Improve code quality and maintainability of the token preservation logic.

Output: Cleaner implementation using Entry API pattern
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/14-scheduler-clone-bug-fix/14-RESEARCH.md
@src/scheduler/scheduler.rs

# Entry API pattern from research
# Pattern 2: HashMap::entry API (Recommended Cleaner Approach)
</context>

<tasks>

<task type="auto">
  <name>Refactor update_iteration_batch to use Entry API</name>
  <files>src/scheduler/scheduler.rs</files>
  <action>
    Add import at top of file (with other HashMap imports):
    ```rust
    use std::collections::hash_map::Entry;
    ```

    Refactor lines 626-645 in update_iteration_batch from:
    ```rust
    // Update remaining processing requests
    // Preserve tokens from processing_requests to avoid losing data from stale batch clones
    for request in batch.requests {
        if !self.processing_requests.contains_key(&request.request_id) {
            // Request was removed (completed), don't re-insert stale clone
            continue;
        }
        if !request.is_complete() && request.state != RequestState::Failed {
            // Check if we have an existing request with more tokens than the batch
            // This can happen if the batch has a stale clone from before token generation
            if let Some(existing) = self.processing_requests.get(&request.request_id) {
                if existing.generated_tokens.len() > request.generated_tokens.len() {
                    // Keep the existing request with more tokens (skip the stale clone)
                    continue;
                }
            }
            // Otherwise, insert/overwrite with the batch's version
            self.processing_requests.insert(request.request_id, request);
        }
    }
    ```

    To Entry API pattern:
    ```rust
    // Update remaining processing requests
    // Use Entry API to preserve tokens - only update if batch has fresher data
    for request in batch.requests {
        if !request.is_complete() && request.state != RequestState::Failed {
            match self.processing_requests.entry(request.request_id) {
                Entry::Vacant(e) => {
                    // Request not in processing (was completed), skip stale clone
                    continue;
                }
                Entry::Occupied(mut e) => {
                    // Only update if batch has more tokens (prevents stale overwrite)
                    if e.get().generated_tokens.len() <= request.generated_tokens.len() {
                        e.insert(request);
                    }
                    // If batch has fewer tokens, keep existing (it's fresher)
                }
            }
        }
    }
    ```

    This refactor:
    - Uses Entry API (idiomatic Rust)
    - Makes intent explicit (Vacant = skip, Occupied = compare then maybe update)
    - Preserves exact same behavior (all tests must pass)
    - Reduces nesting depth
  </action>
  <verify>
    `cargo test --lib -- scheduler:: 2>&1 | grep "test result:"` shows "35 passed; 0 failed"
  </verify>
  <done>
    update_iteration_batch uses Entry API. All 35 scheduler tests pass.
  </done>
</task>

</tasks>

<verification>
Run full scheduler test suite to confirm no behavior change:
```bash
cargo test --lib -- scheduler::
```

Expected: 35 tests passing (same count as plan 01)

Verify Entry API is used:
```bash
grep "Entry::" src/scheduler/scheduler.rs
```
Expected: Entry::Vacant and Entry::Occupied patterns found
</verification>

<success_criteria>
1. Entry API refactor complete
2. All 35 scheduler tests pass (no behavior change)
3. Code is more readable (reduced nesting)
4. Comments explain the Entry API logic
</success_criteria>

<output>
After completion, create `.planning/phases/14-scheduler-clone-bug-fix/14-02-SUMMARY.md`
</output>

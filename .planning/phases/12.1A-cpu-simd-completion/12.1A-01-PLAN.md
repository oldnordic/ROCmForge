---
phase: 12.1A-cpu-simd-completion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/backend/cpu/simd.rs
  - src/attention/cpu.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Runtime CPU detection reports AVX-512 availability on x86_64"
    - "AVX-512 SIMD variants (f32x16) execute for softmax, QK^T, weighted value"
    - "Dynamic dispatch selects optimal SIMD path (AVX-512 > AVX2 > NEON > scalar)"
    - "Fallback to AVX2 when AVX-512 unavailable prevents performance regression"
    - "CPU capabilities logged at startup for debugging"
  artifacts:
    - path: "src/backend/cpu/cpu_features.rs"
      provides: "Runtime CPU feature detection using raw-cpuid"
      exports: ["CpuFeatures", "has_avx512f", "has_avx2", "has_neon"]
      contains: "struct CpuFeatures"
    - path: "src/backend/cpu/simd.rs"
      provides: "AVX-512 SIMD matmul variants (f32x16)"
      contains: "f32x16"
    - path: "src/attention/cpu.rs"
      provides: "Dynamic dispatch for attention operations"
      contains: "softmax_optimized", "qk_t_optimized", "weighted_value_optimized"
  key_links:
    - from: "src/backend/cpu/cpu_features.rs"
      to: "src/backend/cpu/simd.rs"
      via: "CpuFeatures::detect() called at module init"
      pattern: "CpuFeatures::detect|lazy_static|once_cell"
    - from: "src/attention/cpu.rs"
      to: "src/backend/cpu/cpu_features.rs"
      via: "SIMD path selection based on detected features"
      pattern: "cpu_features.*has_avx512"
    - from: "src/backend/cpu/simd.rs"
      to: "std::arch::x86_64"
      via: "AVX-512 intrinsics via std::simd"
      pattern: "_mm512|f32x16"
---

<objective>
AVX-512 Runtime Detection and SIMD Variants

Purpose: Extend CPU SIMD backend to support AVX-512 (512-bit vectors, 16 floats) with runtime CPU feature detection, enabling up to 2x speedup on supported hardware while maintaining AVX2 fallback compatibility.

Output: Runtime CPU detection module, AVX-512 SIMD variants for matmul and attention operations, dynamic dispatch selecting optimal path at runtime.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/12-complete-cpu-simd-attention/12.1-RESEARCH.md
@Cargo.toml
@src/backend/cpu/simd.rs
@src/attention/cpu.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add runtime CPU detection using raw-cpuid</name>
  <files>src/backend/cpu/cpu_features.rs</files>
  <action>
    Create new module src/backend/cpu/cpu_features.rs with:

    1. Add raw-cpuid = "11" to Cargo.toml dependencies

    2. Create CpuFeatures struct with detection methods:
       - `CpuFeatures::detect()` - runs once, caches result using once_cell::sync::Lazy
       - `has_avx512f()` - checks AVX-512 Foundation (bit 16 in EBX)
       - `has_avx2()` - checks AVX2 (bit 5 in EBX)
       - `has_sse41()` - checks SSE4.1 (bit 19 in ECX)
       - `has_neon()` - always returns false on x86_64, uses cfg for aarch64

    3. Use raw-cpuid's CpuId type:
       ```rust
       use raw_cpuid::CpuId;

       pub fn has_avx512f() -> bool {
           #[cfg(target_arch = "x86_64")]
           {
               let cpuid = CpuId::new();
               cpuid.get_feature_info()
                   .map(|info| info.has_avx512f())
                   .unwrap_or(false)
           }
           #[cfg(not(target_arch = "x86_64"))]
           { false }
       }
       ```

    4. Add Debug and Clone derives for CpuFeatures

    5. Add module export in src/backend/cpu/mod.rs
  </action>
  <verify>cargo test --package rocmforge --lib cpu_features 2>&1 | head -50</verify>
  <done>
    - CpuFeatures::detect() returns cached instance
    - has_avx512f() returns correct boolean on x86_64
    - has_avx2() returns correct boolean on x86_64
    - All tests pass (unit tests mock CPUID if unavailable in CI)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement AVX-512 SIMD variants (f32x16)</name>
  <files>src/backend/cpu/simd.rs</files>
  <action>
    Extend src/backend/cpu/simd.rs with AVX-512 support:

    1. Add conditional AVX-512 types (requires nightly std::simd):
       ```rust
       #[cfg(all(target_arch = "x86_64", feature = "avx512"))]
       use std::simd::f32x16;  // AVX-512: 16 floats per vector

       #[cfg(all(target_arch = "x86_64", feature = "avx512"))]
       const AVX512_WIDTH: usize = 16;
       ```

    2. Create avx512_simd_matmul_f32() mirroring simd_matmul_f32 but using f32x16:
       - Process 16 elements per loop iteration
       - Same error handling and validation
       - Scalar fallback for remainder

    3. Add feature flag to Cargo.toml:
       ```toml
       [features]
       avx512 = []  # Enables AVX-512 code paths (requires nightly + AVX-512 CPU)
       ```

    4. Add cfg_attr for SIMD visibility:
       ```rust
       #[cfg_attr(feature = "avx512", path = "simd_avx512.rs")]
       ```

    5. DO NOT use core_arch/std_arch intrinsics directly - use std::simd for portability

    Note: std::simd's f32x16 requires nightly Rust as of Jan 2025. The feature flag allows users to opt-in.
  </action>
  <verify>
    cargo build --features avx512 --lib 2>&1 | grep -E "(error|warning|Compiling rocmforge)" | head -20
  </verify>
  <done>
    - avx512_simd_matmul_f32() compiles with avx512 feature
    - Function returns correct results vs scalar (test validates)
    - No regression in AVX2 code path
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement dynamic dispatch for attention operations</name>
  <files>src/attention/cpu.rs</files>
  <action>
    Add dynamic dispatch to src/attention/cpu.rs:

    1. Create softmax_optimized(), qk_t_optimized(), weighted_value_optimized() functions:
       ```rust
       pub fn softmax_optimized(logits: &[f32]) -> Vec<f32> {
           #[cfg(feature = "avx512")]
           if cpu_features::has_avx512f() {
               return softmax_avx512(logits);
           }
           #[cfg(feature = "simd")]
           if cpu_features::has_avx2() {
               return softmax_simd(logits);
           }
           softmax_scalar(logits)
       }
       ```

    2. Add AVX-512 variants to simd_attention module (inline, not separate file):
       - softmax_avx512 using f32x16
       - qk_t_avx512 using f32x16
       - weighted_value_avx512 using f32x16

    3. Update simd module imports to include cpu_features

    4. Add #[inline(always)] to dispatch functions to ensure runtime optimization

    5. Add tests verifying dispatch selects correct path:
       - Mock cpu_features return values in test cfg
       - Validate output matches scalar reference
  </action>
  <verify>
    cargo test --package rocmforge --lib cpu::attention 2>&1 | grep -E "(test.*PASS|test.*FAIL)" | head -20
  </verify>
  <done>
    - softmax_optimized dispatches to AVX-512 when available
    - Fallback to AVX2 when AVX-512 unavailable
    - Fallback to scalar when no SIMD available
    - All variants produce identical outputs (within tolerance)
  </done>
</task>

</tasks>

<verification>
1. Unit tests for cpu_features module mock CPUID responses
2. Integration tests verify dynamic dispatch on actual hardware (skip in CI)
3. Benchmark comparing AVX-512 vs AVX2 vs scalar performance (document expected speedup)
4. No regression in existing SIMD tests
5. cargo clippy --all-features passes without warnings
</verification>

<success_criteria>
- Runtime CPU detection implemented with raw-cpuid
- AVX-512 SIMD variants (f32x16) for matmul and attention ops
- Dynamic dispatch selects optimal path at runtime
- All tests pass (including mocked tests for CI environments)
- Cargo feature flag avx512 enables AVX-512 code paths
- Fallback to AVX2/scalar prevents performance regression
- CPU capabilities logged at startup (via tracing::info!)
</success_criteria>

<output>
After completion, create `.planning/phases/12.1-cpu-simd-enhancements/12.1-01-SUMMARY.md`
</output>

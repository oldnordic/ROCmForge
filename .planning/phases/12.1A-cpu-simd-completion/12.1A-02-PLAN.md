---
phase: 12.1A-cpu-simd-completion
plan: 02
type: execute
wave: 2
depends_on: ["12.1A-01"]
files_modified:
  - src/backend/cpu/simd_ops.rs
  - src/model/layer/transformer.rs
  - Cargo.toml
autonomous: true
user_setup: []

must_haves:
  truths:
    - "RMSNorm uses SIMD for variance and normalization (8x speedup on AVX2)"
    - "RoPE rotation uses SIMD for sin/cos computation and element-wise ops"
    - "SiLU activation uses SIMD for x * sigmoid(x)"
    - "SwiGLU activation uses SIMD for gate and value projections"
    - "GELU activation uses SIMD for tanh approximation"
    - "All operations have scalar fallbacks for correctness validation"
  artifacts:
    - path: "src/backend/cpu/simd_ops.rs"
      provides: "SIMD implementations of layer normalization and activation functions"
      exports: ["rms_norm_simd", "rope_simd", "silu_simd", "swiglu_simd", "gelu_simd"]
      min_lines: 200
    - path: "src/model/layer/transformer.rs"
      provides: "Transformer layer using SIMD operations"
      contains: "use.*simd_ops::"
  key_links:
    - from: "src/model/layer/transformer.rs"
      to: "src/backend/cpu/simd_ops.rs"
      via: "Import and use of SIMD layer norm/activations"
      pattern: "use crate::backend::cpu::simd_ops::"
    - from: "src/backend/cpu/simd_ops.rs"
      to: "std::simd"
      via: "std::simd f32x8/f32x4 for vectorization"
      pattern: "f32x8|f32x4|Simd"
    - from: "src/backend/cpu/simd_ops.rs"
      to: "src/backend/cpu/cpu_features.rs"
      via: "Dynamic dispatch based on detected CPU features"
      pattern: "cpu_features::|CpuFeatures::"
---

<objective>
Additional SIMD Operations: RMSNorm, RoPE, Activations

Purpose: Implement SIMD-optimized variants of transformer layer operations (RMSNorm, RoPE, SiLU, SwiGLU, GELU) to complete CPU SIMD coverage for all common transformer operations.

Output: New simd_ops.rs module with SIMD layer norm and activation functions, integrated into transformer layer execution.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/12-complete-cpu-simd-attention/12.1-RESEARCH.md
@src/backend/cpu/simd.rs
@src/attention/cpu.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SIMD layer normalization module (RMSNorm)</name>
  <files>src/backend/cpu/simd_ops.rs</files>
  <action>
    Create new module src/backend/cpu/simd_ops.rs with:

    1. Module structure:
       ```rust
       use std::simd::{f32x4, f32x8, Simd};
       use std::simd::prelude::SimdFloat;

       #[cfg(target_arch = "x86_64")]
       type SimdF32 = f32x8;
       #[cfg(target_arch = "aarch64")]
       type SimdF32 = f32x4;
       // ... SIMD_WIDTH const
       ```

    2. RMSNorm (Root Mean Square Layer Normalization):
       ```rust
       pub fn rms_norm_simd(input: &[f32], weight: &[f32], eps: f32) -> Vec<f32> {
           // 1. Compute mean square: (1/n) * sum(x^2)
           // 2. Normalize: x / sqrt(ms + eps)
           // 3. Scale: result * weight
       }
       ```
       - SIMD for sum of squares (8 elements at a time)
       - SIMD for normalize-scale (vector multiply)
       - Scalar fallback for remainder

    3. Scalar reference implementation rms_norm_scalar()

    4. Dynamic dispatch rms_norm() using cpu_features from 12.1-01

    5. Tests:
       - Compare SIMD vs scalar output
       - Test alignment handling (non-multiple of SIMD_WIDTH)
       - Test zero input handling

    Formula: RMSNorm(x) = x / sqrt(mean(x^2) + eps) * weight
  </action>
  <verify>cargo test --package rocmforge --lib simd_ops::rms_norm 2>&1 | grep -E "(test|PASS|FAIL)"</verify>
  <done>
    - rms_norm_simd produces identical output to scalar (within tolerance)
    - Handles arbitrary input lengths
    - Tests pass for edge cases (zeros, negative values)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SIMD RoPE (Rotary Position Embedding)</name>
  <files>src/backend/cpu/simd_ops.rs</files>
  <action>
    Add RoPE SIMD implementation to simd_ops.rs:

    1. RoPE formula:
       ```
       For each pair (x_{2i}, x_{2i+1}):
         freq = 1 / (10000 ^ (2i / d))
         cos_val = cos(pos * freq)
         sin_val = sin(pos * freq)
         x'_{2i} = x_{2i} * cos_val - x_{2i+1} * sin_val
         x'_{2i+1} = x_{2i} * sin_val + x_{2i+1} * cos_val
       ```

    2. Implementation:
       ```rust
       pub fn rope_simd(
           input: &mut [f32],
           pos: usize,
           dim: usize,
           theta: f32,  // 10000.0
       ) {
           // Process pairs of elements (2i, 2i+1)
           // SIMD for sin/cos computation
           // SIMD for rotation (multiply-add)
       }
       ```

    3. Precompute freqs with SIMD:
       - Compute powers of theta using SIMD exp approximation
       - Store in lookup table for repeated use

    4. Scalar fallback rope_scalar()

    5. Dynamic dispatch rope()

    6. Tests:
       - Verify rotation preserves vector magnitude
       - Test position increments produce expected phase shift
  </action>
  <verify>cargo test --package rocmforge --lib simd_ops::rope 2>&1 | grep -E "(test|PASS|FAIL)"</verify>
  <done>
    - rope_simd produces same output as scalar
    - SIMD speedup on 128+ dim (4 pairs processed per iteration)
    - Tests verify mathematical properties of rotation
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement SIMD activation functions (SiLU, SwiGLU, GELU)</name>
  <files>src/backend/cpu/simd_ops.rs</files>
  <action>
    Add activation functions to simd_ops.rs:

    1. SiLU (Swish): x * sigmoid(x)
       ```rust
       pub fn silu_simd(x: &[f32]) -> Vec<f32> {
           // sigmoid approx: 1 / (1 + exp(-x))
           // SIMD for exp, multiply
       }

       pub fn silu_in_place_simd(x: &mut [f32]) {
           // In-place variant for memory efficiency
       }
       ```

    2. SwiGLU: (x * W) * SiLU(x * V)
       ```rust
       pub fn swiglu_simd(gate: &[f32], value: &[f32]) -> Vec<f32> {
           // Element-wise: silu(gate) * value
           // SIMD for silu, then multiply
       }
       ```

    3. GELU: x * Phi(x) where Phi is CDF of standard normal
       ```rust
       pub fn gelu_simd(x: &[f32]) -> Vec<f32> {
           // Approximation: 0.5 * x * (1 + tanh(sqrt(2/pi) * (x + 0.044715 * x^3)))
           // SIMD for polynomial, tanh approx
       }
       ```

    4. Use polynomial/tanh approximations:
       - exp: 4th-degree Taylor (already in simd_attention)
       - tanh: rational approximation or std::f32::tanh with SIMD application

    5. Scalar fallbacks for all

    6. Tests:
       - Compare against std::f32::exp/tanh for accuracy
       - Verify SiLU(x) > 0 for x > 0
       - Test SwiGLU combines gate/value correctly
  </action>
  <verify>cargo test --package rocmforge --lib simd_ops::activations 2>&1 | grep -E "(test|PASS|FAIL)"</verify>
  <done>
    - All SIMD activations match scalar within tolerance
    - Performance benchmark shows >4x speedup on AVX2
    - Tests cover edge cases (large positive/negative, zeros)
  </done>
</task>

</tasks>

<verification>
1. All SIMD operations validated against scalar reference
2. Tests for alignment handling (non-multiple of SIMD_WIDTH)
3. Mathematical property tests (RoPE preserves magnitude, SiLU positive)
4. No clippy warnings
5. Integration test in transformer layer uses SIMD ops
</verification>

<success_criteria>
- simd_ops.rs module with 5 operations (RMSNorm, RoPE, SiLU, SwiGLU, GELU)
- All operations have scalar fallbacks
- Dynamic dispatch based on CPU features
- Tests verify correctness vs scalar
- Transformer layer uses SIMD ops where applicable
- Cargo clippy clean
</success_criteria>

<output>
After completion, create `.planning/phases/12.1-cpu-simd-enhancements/12.1-02-SUMMARY.md`
</output>

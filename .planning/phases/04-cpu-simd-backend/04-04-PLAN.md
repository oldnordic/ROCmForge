---
phase: 04-cpu-simd-backend
plan: 04
type: execute
depends_on: ["04-02", "04-03"]
files_modified: [src/backend/mod.rs, src/backend/cpu_backend.rs]
autonomous: true
---

<objective>
Add CPU feature detection and runtime selection between SIMD and scalar paths.

Purpose: Enable transparent CPU fallback with automatic feature detection
Output: CPU backend that adapts to hardware capabilities
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-cpu-simd-backend/04-01-PLAN.md
@.planning/phases/04-cpu-simd-backend/04-02-PLAN.md
@.planning/phases/04-cpu-simd-backend/04-03-PLAN.md
@src/backend/cpu_backend.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CPU feature detection</name>
  <files>src/backend/cpu_backend.rs, src/backend/mod.rs</files>
  <action>
    Add runtime feature detection for CPU capabilities:

    ```rust
    // In src/backend/cpu_backend.rs

    /// Detect CPU SIMD capabilities at runtime
    fn detect_simd_capabilities() -> bool {
        #[cfg(target_arch = "x86_64")]
        {
            // Check for AVX2 support via cpuid or compile-time cfg
            cfg!(target_arch = "x86_64") // Will have at least SSE2
        }

        #[cfg(target_arch = "aarch64")]
        {
            // Check for NEON support
            cfg!(target_arch = "aarch64") // Will have NEON
        }

        #[cfg(not(any(target_arch = "x86_64", target_arch = "aarch64"))]
        {
            false
        }
    }

    // OR use cpuid crate for runtime detection (cross-platform):
    // #[cfg(target_arch = "x86_64")]
    // {
    //     use raw_cpuid::CpuId;
    //     let cpuid = CpuId::new();
    //     let has_avx2 = cpuid.feature_set_contains(CFIA, 0); // Check AVX2
    // }
    ```
  </action>
  <verify>Feature detection works on target platforms</verify>
  <done>SIMD detection implemented</done>
</task>

<task type="auto">
  <name>Task 2: Add CpuBackend to backend registry</name>
  <files>src/backend/mod.rs, src/backend/cpu_backend.rs</files>
  <action>
    1. Export CpuBackend in src/backend/mod.rs:
       ```rust
       pub mod cpu_backend;
       pub use cpu_backend::CpuBackend;
       ```

    2. Update backend registry to include CPU backend option:
       ```rust
       pub enum BackendType {
           Hip,     // ROCm/HIP GPU backend
           Cpu,     // SIMD-accelerated CPU backend
       }
       ```

    3. Implement CpuBackend::new() to run feature detection
     </action>
  <verify>cargo check passes</verify>
  <done>CpuBackend integrated into backend system</done>
</task>

<task type="auto">
  <name>Task 3: Implement runtime SIMD/scalar selection</name>
<files>src/backend/cpu_backend.rs</files>
  <action>
    Update matmul and attention operations to use SIMD when available:

    ```rust
    impl CpuBackend {
        fn execute_op(&mut self, op: &Op, inputs: &[TensorId], outputs: &[TensorId]) -> GgmlResult<()> {
            match op {
                Op::MatMul { .. } => {
                    if self.simd_capable {
                        self.matmul_simd(inputs, outputs)?;
                    } else {
                        self.matmul_scalar(inputs, outputs)?;
                    }
                }
                Op::Softmax { .. } => {
                    if self.simd_capable {
                        self.softmax_simd(inputs, outputs)?;
                    } else {
                        self.softmax_scalar(inputs, outputs)?;
                    }
                }
                // Other operations...
            }
        }
    }
    ```
  </action>
  <verify>cargo check passes</verify>
  <done>Runtime SIMD selection implemented</done>
</task>

</tasks>

<verification>
- [ ] CPU feature detection implemented
- [ ] CpuBackend exported in mod.rs
- [ ] Backend registry includes CPU option
- [ ] SIMD/scalar selection based on capabilities
- [ ] cargo check passes
- [ ] Integration tests pass
</verification>

<success_criteria>
- CpuBackend detects SIMD capabilities at runtime
- Backend system can select CPU backend with SIMD
- Fallback to scalar when SIMD unavailable
- Transparent to higher-level code
</success_criteria>

<output>
After completion, create `.planning/phases/04-cpu-simd-backend/04-04-SUMMARY.md`
</output>

---
phase: 21-test-health-and-performance-validation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/kv_cache/kv_cache.rs
  - tests/edge_case_tests.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "KV cache respects max_pages limit at capacity"
    - "allocate_page returns CapacityExceeded error when full"
    - "test_kv_cache_eviction_at_capacity passes"
  artifacts:
    - path: "src/kv_cache/kv_cache.rs"
      provides: "allocate_page with capacity enforcement"
      contains: "allocate_page.*max_pages"
    - path: "tests/edge_case_tests.rs"
      provides: "KV cache eviction test"
  key_links:
    - from: "tests/edge_case_tests.rs"
      to: "src/kv_cache/kv_cache.rs"
      via: "KvCache::allocate_page"
      pattern: "cache\\.allocate_page"
---

<objective>
Fix KV cache capacity enforcement bug where allocate_page allows exceeding max_pages.

Purpose: The test `test_kv_cache_eviction_at_capacity` expects `allocate_page` to fail with `CapacityExceeded` when the cache is full, but the current implementation allows allocating beyond max_pages. The issue is in the capacity check logic.

Output: KV cache properly enforces max_pages limit and returns CapacityExceeded error when full.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md

@src/kv_cache/kv_cache.rs
@tests/edge_case_tests.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix allocate_page capacity check logic</name>
  <files>src/kv_cache/kv_cache.rs</files>
  <action>
    The issue is in the `allocate_page` function (around line 711-744). The current logic:
    ```rust
    let current_pages = self.pages.read()?.len();
    let has_free_page = self.free_pages.read()?.is_empty();

    if current_pages >= self.config.max_pages && has_free_page {
        // Try LRU eviction...
    }

    // Try to reuse a free page first
    let page_id = if let Some(free_id) = self.free_pages.write()?.pop() {
        free_id
    } else if self.pages.read()?.len() >= self.config.max_pages {
        return Err(KvCacheError::CapacityExceeded);
    } else {
        // allocate new page...
    };
    ```

    The problem: The first check `current_pages >= self.config.max_pages && has_free_page` will NOT trigger when `has_free_page` is false (empty free_pages). But then the second check happens, and if free_pages is empty, it correctly checks `self.pages.read()?.len() >= self.config.max_pages`.

    However, the test creates cache with max_pages=3 and successfully allocates 3 pages for sequences 1, 2, 3. Then it tries to allocate for sequence 4 and expects failure.

    The actual issue may be in how pages are counted or how the check happens. Read the full allocate_page function and fix the logic so that:
    1. Total allocated pages never exceeds max_pages
    2. When at capacity, new allocations return Err(KvCacheError::CapacityExceeded)
    3. Free pages can be reused (reducing total allocation count)

    Fix: Change the check to correctly track total allocated pages vs max_pages regardless of free_pages state.
  </action>
  <verify>
    cargo test --features rocm --test edge_case_tests test_kv_cache_eviction_at_capacity 2>&1 | tail -20
  </verify>
  <done>
    test_kv_cache_eviction_at_capacity passes. The cache correctly returns CapacityExceeded error when attempting to allocate beyond max_pages.
  </done>
</task>

</tasks>

<verification>
After task completes:
1. `cargo test --features rocm --test edge_case_tests test_kv_cache_eviction_at_capacity` passes
2. Test output shows "Should fail when cache is full" assertion passes
3. No other KV cache tests regress
</verification>

<success_criteria>
- TEST-02: test_kv_cache_eviction_at_capacity passes
- KV cache properly enforces max_pages limit
- CapacityExceeded error is returned when cache is full
</success_criteria>

<output>
After completion, create `.planning/phases/21-test-health-and-performance-validation/21-02-SUMMARY.md`
</output>

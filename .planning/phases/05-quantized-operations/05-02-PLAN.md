---
phase: 05-quantized-operations
plan: 02
type: execute
depends_on: ["05-01"]
files_modified: [kernels/q4_0_dequant.hip, build.rs, src/ggml/hip_backend/ops/q4_0_dequant.rs]
autonomous: true
---

<objective>
Implement HIP dequantization kernel for Q4_0 format.

Purpose: Enable on-GPU dequantization of Q4_0 quantized weights, eliminating CPU-GPU data transfer overhead. Q4_0 is the most common quantization format for LLM weights.
Output: Working Q4_0 HIP kernel with Rust wrapper, integrated into build system.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/05-quantized-operations/05-01-SUMMARY.md
@src/loader/dequant.rs
@kernels/mxfp_dequant.hip
@build.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Q4_0 dequantization HIP kernel</name>
  <files>kernels/q4_0_dequant.hip</files>
  <action>
    Create kernels/q4_0_dequant.hip following the pattern from mxfp_dequant.hip:

    Q4_0 format specification:
    - Block size: 32 elements
    - Per block: scale (f32, 4 bytes) + 16 bytes 4-bit packed values = 20 bytes
    - Dequantization: value = scale * ((packed & 0x0F) - 8) for low nibble
    - Dequantization: value = scale * (((packed >> 4) & 0x0F) - 8) for high nibble

    Kernel requirements:
    - Grid: (num_blocks, 1, 1) - one block per Q4_0 block
    - Block: 256 threads (8 waves of 32 for RDNA3)
    - Each thread processes one element in the 32-element block
    - Device function for unpacking 4-bit values

    Implement two kernels:
    1. q4_0_to_fp32_kernel - Basic dequantization (one block per quantized block)
    2. q4_0_to_fp32_batch_kernel - Optimized for multiple blocks

    Follow mxfp_dequant.hip structure:
    - Include guards and kernel documentation
    - constexpr tuning constants for RDNA3
    - extern "C" __global__ kernel entry points
    - Proper __restrict__ pointers for compiler optimization
    - Boundary checking (block_idx >= num_blocks return)
  </action>
  <verify>q4_0_dequant.hip created with valid HIP kernel code</verify>
  <done>Q4_0 HIP kernel source file created</done>
</task>

<task type="auto">
  <name>Task 2: Add Q4_0 kernel to build system</name>
  <files>build.rs</files>
  <action>
    Add Q4_0 dequant kernel to build.rs kernels array:

    Add entry after MXFP kernels:
    ```rust
    (
        "kernels/q4_0_dequant.hip",
        "Q4_0_DEQUANT_HSACO",
        "q4_0_to_fp32_kernel",
    ),
    ```

    This will:
    - Compile the HIP kernel during build
    - Set Q4_0_DEQUANT_HSACO env var to HSACO path
    - Make kernel available to Rust code via link section
  </action>
  <verify>build.rs updated with q4_0_dequant entry</verify>
  <done>Q4_0 kernel added to build system</done>
</task>

<task type="auto">
  <name>Task 3: Create Rust wrapper for Q4_0 kernel</name>
  <files>src/ggml/hip_backend/ops/q4_0_dequant.rs</files>
  <action>
    Create src/ggml/hip_backend/ops/q4_0_dequant.rs with:

    1. External function declarations for HIP kernels:
       ```rust
       extern "C" {
           fn q4_0_to_fp32_kernel(
               input: *const u8,
               output: *mut f32,
               num_blocks: i32,
           );
           fn q4_0_to_fp32_batch_kernel(
               input: *const u8,
               output: *mut f32,
               num_elements: i32,
           );
       }
       ```

    2. Wrapper function for launching kernel:
       ```rust
       pub fn dequantize_q4_0_gpu(
           backend: &crate::backend::HipBackend,
           quantized_data: &[u8],
           num_elements: usize,
       ) -> Result<Vec<f32>, String> {
           // Calculate blocks (32 elements per block)
           let num_blocks = (num_elements + 31) / 32;

           // Allocate output buffer
           let mut output = vec![0.0f32; num_elements];

           // Launch kernel
           let num_blocks_i32 = num_blocks as i32;
           unsafe {
               q4_0_to_fp32_batch_kernel(
                   quantized_data.as_ptr(),
                   output.as_mut_ptr(),
                   num_blocks_i32,
               );
           }

           // Synchronize and return
           backend.synchronize().map_err(|e| format!("Sync failed: {:?}", e))?;
           Ok(output)
       }
       ```

    3. Re-export from mod.rs:
       Add `pub mod q4_0_dequant;` to src/ggml/hip_backend/ops/mod.rs
  </action>
  <verify>Rust wrapper created and module exported</verify>
  <done>Q4_0 Rust wrapper implemented and integrated</done>
</task>

<task type="auto">
  <name>Task 4: Add test for Q4_0 GPU dequantization</name>
  <files>src/ggml/hip_backend/ops/q4_0_dequant.rs</files>
  <action>
    Add test in q4_0_dequant.rs following pattern from quantized_matmul.rs:

    ```rust
    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn test_q4_0_dequant_kernel() {
            // Create test data: 1 block with scale=1.0, all values = 8 (dequantizes to 0.0)
            let mut data = vec![0u8; 20];  // 1 block * 20 bytes

            // Scale = 1.0
            data[0..4].copy_from_slice(&1.0f32.to_le_bytes());

            // Pack 32 values, all stored as 8 (representing 0.0 after dequant)
            for i in 0..16 {
                data[4 + i] = 0x88;  // Both nibbles = 8
            }

            // Call kernel (note: requires GPU, use #[ignore] if no GPU)
            let result = dequantize_q4_0_gpu(&backend, &data, 32).unwrap();

            // All values should be 0.0
            for i in 0..32 {
                assert!((result[i] - 0.0).abs() < 0.01, "result[{}]={}", i, result[i]);
            }
        }
    }
    ```

    Mark test with #[ignore] if it requires real GPU hardware.
  </action>
  <verify>Test created and compiles</verify>
  <done>Test for Q4_0 GPU dequantization added</done>
</task>

</tasks>

<verification>
- [ ] kernels/q4_0_dequant.hip created with valid HIP kernels
- [ ] build.rs updated to compile Q4_0 kernel
- [ ] Rust wrapper created in q4_0_dequant.rs
- [ ] Module exported in ops/mod.rs
- [ ] Test created (may require #[ignore] for GPU dependency)
- [ ] cargo check passes
</verification>

<success_criteria>
- Q4_0 HIP kernel compiles successfully with hipcc
- Rust wrapper can launch the kernel
- Test validates correct dequantization (when GPU available)
- Code follows established patterns from mxfp_dequant.hip
</success_criteria>

<output>
After completion, create `.planning/phases/05-quantized-operations/05-02-SUMMARY.md`
</output>
